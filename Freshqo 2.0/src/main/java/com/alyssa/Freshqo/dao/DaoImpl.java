package com.alyssa.Freshqo.dao;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;
import javax.sql.DataSource;
import javax.swing.ImageIcon;

import org.apache.commons.dbcp.BasicDataSource;

import com.alyssa.Freshqo.config.Configuration;
import com.alyssa.Freshqo.data.CustomerQueue;
import com.alyssa.Freshqo.data.DoublyLinkedList;
import com.alyssa.Freshqo.data.Queue;
import com.alyssa.Freshqo.domain.Chef;
import com.alyssa.Freshqo.domain.Customer;
import com.alyssa.Freshqo.domain.Employee;
import com.alyssa.Freshqo.domain.Manager;
import com.alyssa.Freshqo.domain.MenuItem;
import com.alyssa.Freshqo.domain.Reservation;
import com.alyssa.Freshqo.domain.ReservationDateTime;
import com.alyssa.Freshqo.domain.Table;
import com.alyssa.Freshqo.domain.TableOrder;
import com.alyssa.Freshqo.domain.TableOrderItem;
import com.alyssa.Freshqo.domain.Waiter;
import com.alyssa.Freshqo.utils.Utils;

/**
 * DaoImpl
 * 
 * Data Access Object implementation class that implements database operations
 * 
 * @author Alyssa Gao
 * @version 1.0
 * @date June 13, 2019
 */
public class DaoImpl implements Dao {

	private static Dao _dao = null;

	private DaoImpl() {
		BasicDataSource basicDataSource = new BasicDataSource();
		basicDataSource.setDriverClassName(Configuration.DB_DRIVER_CLASS_NAME);
		basicDataSource.setUrl(Configuration.DB_URL);
		basicDataSource.setUsername(Configuration.DB_USERNAME);
		basicDataSource.setPassword(Configuration.DB_PASSWORD);

		this.dataSource = basicDataSource;
	}

	/**
	 * Create a singleton instance of Dao implementation.
	 * 
	 * @return a singleton instance of Dao implementation.
	 */
	public static Dao getInstance() {
		if (_dao == null) {
			_dao = new DaoImpl();
		}
		return _dao;
	}

	private DataSource dataSource;
	
	//////////////// Save Data ///////////////

	/**
	 * clearData clear all database data.
	 */
	@Override
	public void clearData() throws SQLException {
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement(); ) {
			stmt.executeUpdate("DELETE FROM RESERVATION");
			stmt.executeUpdate("DELETE FROM TABLE_ORDER_ITEM");
			stmt.executeUpdate("DELETE FROM TABLE_ORDER");
			stmt.executeUpdate("DELETE FROM RES_TABLE");
			stmt.executeUpdate("DELETE FROM MENU_ITEM");
			stmt.executeUpdate("DELETE FROM WAITING_LIST");
			stmt.executeUpdate("DELETE FROM CUSTOMER");
			stmt.executeUpdate("DELETE FROM EMPLOYEE");
		}
	}
	
	/**
	 * saveEmployees save a list of employees to database.
	 *  @param employees a list of employees to be saved to database.
	 *  @exception SQLException when encountered a database error
	 */
	@Override
	public void saveEmployees ( List<Employee> employees ) throws SQLException {
		try ( Connection conn = this.dataSource.getConnection(); 
			  PreparedStatement stmt = conn.prepareStatement( "INSERT INTO EMPLOYEE (NAME, PAY, USER_ID, PASSWORD, DATE_HIRED, EMAIL, SIN_NUM, POSITION, EMP_TYPE) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ? )" ) ) {
			conn.setAutoCommit(false);
			for ( Employee employee : employees ) {
				stmt.setString( 1, employee.getName() );
				stmt.setDouble( 2, employee.getPay() );
				stmt.setString( 3, employee.getUserID() );
				stmt.setString( 4, employee.getPassword() );
				stmt.setString( 5, employee.getDateHired() );
				stmt.setString( 6, employee.getEmail() );
				stmt.setString( 7, employee.getSINNumber() );
				stmt.setString( 8, employee.getPosition() );
				String employeeType;
				if ( employee instanceof Manager ) {
					employeeType = "M";
				} else if ( employee instanceof Waiter ) {
					employeeType = "W";
				} else if ( employee instanceof Chef ) {
					employeeType = "C";
				} else {
					employeeType = "E";
				}
				stmt.setString( 9, employeeType );
				stmt.addBatch();
			}
			int[] counts = stmt.executeBatch();
			conn.commit();
			conn.setAutoCommit( true );
		}
	}
	
	private boolean doesCustomerExist ( Connection conn, Customer customer ) throws SQLException {
		try ( PreparedStatement stmt = 
				conn.prepareStatement( "SELECT * FROM CUSTOMER WHERE NAME = ?" ) ) {
			stmt.setString( 1, customer.getName() );
			ResultSet rs = stmt.executeQuery();
			return rs.next();
			}
	}
	
	/**
	 * Save a single customer object and returns the customer ID.
	 * @param conn the current database connection
	 * @param customer the customer to be persisted
	 * @return a new customer ID generated by the database if the customer doesn't exist, 
	 * or an existing customer ID if the customer already exists.
	 * @throws SQLException when encountered a database error
	 */
	private int saveCustomer ( Connection conn, Customer customer ) throws SQLException {
		if ( customer == null ) {
			return -1;
		}
		if ( doesCustomerExist(conn, customer) ) {
			return retrieveIDByName(conn, "SELECT ID FROM CUSTOMER WHERE NAME = ?", customer.getName() );
		} else {
			try ( PreparedStatement stmt = 
					conn.prepareStatement( "INSERT INTO CUSTOMER (NAME, NUM_OF_PEOPLE) VALUES ( ?, ? )", Statement.RETURN_GENERATED_KEYS ) ) {
				stmt.setString( 1, customer.getName() );
				stmt.setInt( 2, customer.getNumPeople() );
				stmt.executeUpdate();
				
				ResultSet rs = stmt.getGeneratedKeys();
			    if (rs.next()) {
			       return rs.getInt(1);
			    } else {
			    	throw new SQLException ( "Error in retrieve customer ID for customer of " + customer.getName() );
			    }
			}
		}
	}
	
	private int retrieveIDByName ( Connection conn, String sql, String name ) throws SQLException {
		try ( PreparedStatement stmt = conn.prepareStatement( sql ) ) {
				stmt.setString( 1, name );
				ResultSet rs = stmt.executeQuery();
				if ( rs.next() ) {
					return rs.getInt( "ID" );
				} else {
					throw new SQLException ( "No record found with the name of " + name );
				}
			}
	}

	/**
	 * Save reservation book to database
	 * @param reservationBook a list of Reservation objects that are expected to save to database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public void saveReservationBook(List<Reservation> reservationBook) throws SQLException {
		try ( Connection conn = this.dataSource.getConnection(); 
				  PreparedStatement stmt = conn.prepareStatement( "INSERT INTO RESERVATION (TABLE_ID, CUSTOMER_ID, RESERVED_DATE, RESERVED_TIME, CLAIMED) VALUES ( ?, ?, ?, ?, ? )" ) ) {
			
				conn.setAutoCommit( false );

//				List<Customer> customersWithReservation = new ArrayList<>();
//				for ( Reservation reservation : reservationBook ) {
//					customersWithReservation.add( reservation.getCustomer() );
//				}
//				saveCustomers ( conn, customersWithReservation );
				
				for ( Reservation reservation : reservationBook ) {
					int customerID = saveCustomer(conn, reservation.getCustomer() );
					int tableID = retrieveIDByName(conn, "SELECT ID FROM RES_TABLE WHERE TABLE_NAME = ?", reservation.getTable().getTableName() );
					stmt.setInt( 1, tableID );
					stmt.setInt( 2, customerID );
					stmt.setString( 3, reservation.getReservationDateTime().getDate() );
					stmt.setString( 4, reservation.getReservationDateTime().getTime() );
					stmt.setString( 5, reservation.isClaimed() ? "Y" : "N" );
					stmt.addBatch();
				}
				int[] counts = stmt.executeBatch();
				conn.commit();
				conn.setAutoCommit( true );
			}
	}

	/**
	 * Save restaurant tables to database
	 * @param tables a list of Table objects that are expected to save to database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public void saveTables(List<Table> tables) throws SQLException {
		try ( Connection conn = this.dataSource.getConnection() ) {
			
			conn.setAutoCommit( false );

			for ( Table table : tables ) {
				try ( PreparedStatement stmt = conn.prepareStatement( "INSERT INTO RES_TABLE (TABLE_NAME, NUM_SEATS, CUSTOMER_ID, CAN_BE_SERVED, WAITER_ID, OCCUPIED) VALUES ( ?, ?, ?, ?, ?, ? )", Statement.RETURN_GENERATED_KEYS ) ) {
					int customerID = saveCustomer(conn, table.getCustomer() );
					int waiterID = -1;
					if ( table.getCurrentAssignedWaiter() != null ) {
						waiterID = retrieveIDByName(conn, "SELECT ID FROM EMPLOYEE WHERE EMP_TYPE = 'W' AND USER_ID = ?", table.getCurrentAssignedWaiter().getUserID() );
					}
					stmt.setString( 1, table.getTableName() );
					stmt.setInt( 2, table.getNumSeats() );
					if ( customerID >= 0 ) {
						stmt.setInt( 3, customerID );
					} else {
						stmt.setNull( 3, Types.INTEGER );
					}
					stmt.setString( 4, table.canBeReserved() ? "Y" : "N" );
					if ( waiterID >= 0 ) {
						stmt.setInt( 5,  waiterID );
					} else {
						stmt.setNull( 5, Types.INTEGER );
					}
					stmt.setString( 6, table.isOccupied() ? "Y" : "N" );
					stmt.executeUpdate();

					if ( table.getCurrentOrder() != null && table.getCurrentOrder().getTransactionID() != null ) {
						ResultSet rs = stmt.getGeneratedKeys();
						if (rs.next()) {
							int tableID = rs.getInt(1);
							saveTableOrder(conn, table.getCurrentOrder(), tableID);
						} else {
							throw new SQLException ( "Failed to save table: " + table.getTableName() );
						}
					}
				}
			}
			conn.commit();
			conn.setAutoCommit( true );
		}
	}

	/**
	 * Save the waiting list to database
	 * @param waitingList a list of Customer objects that are in the waiting list and are expected to save to database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public void saveWaitingList(CustomerQueue<Customer> waitingList) throws SQLException {
		try ( Connection conn = this.dataSource.getConnection(); 
				  PreparedStatement stmt = conn.prepareStatement( "INSERT INTO WAITING_LIST (CUSTOMER_ID) VALUES ( ? )" ) ) {
			
				conn.setAutoCommit( false );

				@SuppressWarnings("unchecked")
				Iterator<Customer> customerIterator = waitingList.iterator();
				while ( customerIterator.hasNext() ) {
					Customer customer = customerIterator.next();
					int customerID = -1;
					try {
						customerID = retrieveIDByName(conn, "SELECT ID FROM CUSTOMER WHERE NAME = ?", customer.getName() );
					} catch ( Exception e ) {
						// no customer found or there's a DB error;
					}
					if ( customerID == -1 ) {
						customerID = saveCustomer(conn, customer);
					}
					stmt.setInt( 1, customerID );
					stmt.addBatch();
				}
				int[] counts = stmt.executeBatch();
				conn.commit();
				conn.setAutoCommit( true );
			}
	}

	/**
	 * Save restaurant menu to database
	 * @param menu a list of MenuItem objects that are expected to save to database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public void saveMenu(List<MenuItem> menu) throws SQLException, IOException {
		try ( Connection conn = this.dataSource.getConnection() ) {
			
				conn.setAutoCommit( false );

				for ( MenuItem menuItem : menu ) {
					try ( PreparedStatement stmt = conn.prepareStatement( "INSERT INTO MENU_ITEM (NAME, PRICE, DESCRIPTION, CATEGORY) VALUES ( ?, ?, ?, ? )", Statement.RETURN_GENERATED_KEYS ) ) {
						stmt.setString( 1, menuItem.getName() );
						stmt.setDouble( 2, menuItem.getPrice() );
						stmt.setString( 3, "" ); // description is not currently used.
						stmt.setString( 4, menuItem.getCategory() );
						stmt.executeUpdate();

						if ( menuItem.getInternalIconImage() != null ) {
							ResultSet rs = stmt.getGeneratedKeys();
							if (rs.next()) {
								int menuitemID = rs.getInt(1);
								saveMenuItemImage(conn, menuItem, menuitemID);
							} else {
								throw new SQLException ( "Failed to save menu item: " + menuItem.getName() );
							}
						}
					}
				}
				conn.commit();
				conn.setAutoCommit( true );
			}
	}
	
	private void saveMenuItemImage ( Connection conn, MenuItem menuItem, int menuItemID ) throws SQLException, IOException {
		try ( PreparedStatement stmt = conn.prepareStatement( "UPDATE MENU_ITEM SET ICON_IMG = ? WHERE ID = ?" ) ) {

//			byte[] imageBytes = Utils.icon2Bytes( menuItem.getInternalIconImage() );
			stmt.setBlob(1, new ByteArrayInputStream( menuItem.getInternalIconImage() ) );
			stmt.setInt( 2, menuItemID );
			stmt.executeUpdate();
		}
	}
	
	/**
	 * Save historical transactions (table orders and order items) to database
	 * @param menu a list of TableOrder objects that are completed (i.e., paid) and expected to save to database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public void saveHistoricalTransactions(List<TableOrder> historicalTransactions) throws SQLException {
		try ( Connection conn = this.dataSource.getConnection() ) {

			conn.setAutoCommit( false );

			for ( TableOrder tableOrder : historicalTransactions ) {
				try ( PreparedStatement stmt = conn.prepareStatement( "INSERT INTO TABLE_ORDER (TRANSACTION_ID, TABLE_ID, WAITER_ID, ORDER_DATE, SUB_TOTAL, TOTAL, IS_PAID, STATUS) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )", Statement.RETURN_GENERATED_KEYS ) ) {
					int waiterID = retrieveIDByName(conn, "SELECT ID FROM EMPLOYEE WHERE EMP_TYPE = 'W' AND USER_ID = ?", tableOrder.getWaiter().getUserID() );
					int tableID = retrieveIDByName(conn, "SELECT ID FROM RES_TABLE WHERE TABLE_NAME = ?", tableOrder.getTable().getTableName() );
					stmt.setString( 1, tableOrder.getTransactionID() );
					stmt.setInt( 2, tableID );
					stmt.setInt( 3, waiterID );
					stmt.setString( 4, tableOrder.getDate() );
					stmt.setDouble( 5, tableOrder.getSubtotal() );
					stmt.setDouble( 6, tableOrder.getTotal() );
					stmt.setString( 7, tableOrder.hasPaid() ? "Y" : "N" );
					stmt.setString( 8, "H" );	
					stmt.executeUpdate();

					ResultSet rs = stmt.getGeneratedKeys();
				    if (rs.next()) {
				       int tableOrderID = rs.getInt(1);
				       saveTableOrderItems(conn, tableOrder.getOrderItems(), tableOrderID, true);
				    } else {
				    	throw new SQLException ( "Failed to save table order: " + tableOrder.getTransactionID() );
				    }
				}
			}
			conn.commit();
			conn.setAutoCommit( true );
		}
	}
	
	private void saveTableOrderItems ( Connection conn, List<TableOrderItem> tableOrderItems, int tableOrderID, boolean isHistoricalOrderItem ) throws SQLException {
		try ( PreparedStatement stmt = conn.prepareStatement( "INSERT INTO TABLE_ORDER_ITEM (MENU_ITEM_ID, QUANTITY, WAITER_ID, CHEF_ID, TABLE_ORDER_ID, IS_FIRED, HAS_SERVED, STATUS) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )" ) ) {
			
			for ( TableOrderItem tableOrderItem : tableOrderItems ) {
				int waiterID = retrieveIDByName(conn, "SELECT ID FROM EMPLOYEE WHERE EMP_TYPE = 'W' AND USER_ID = ?", tableOrderItem.getServedByWaiter().getUserID() );
				int menuitemID = retrieveIDByName ( conn, "SELECT ID FROM MENU_ITEM WHERE NAME = ?", tableOrderItem.getMenuItem().getName() );
				stmt.setInt( 1, menuitemID );
				stmt.setInt( 2, tableOrderItem.getQuantity() );
				stmt.setInt( 3, waiterID );
				if ( tableOrderItem.getPreparedByChef() != null ) {
					int chefID = retrieveIDByName(conn, "SELECT ID FROM EMPLOYEE WHERE EMP_TYPE = 'C' AND USER_ID = ?", tableOrderItem.getPreparedByChef().getUserID() );
					stmt.setInt( 4, chefID );
				} else {
					stmt.setNull( 4, Types.INTEGER );
				}
				stmt.setInt( 5, tableOrderID );
				stmt.setString( 6, tableOrderItem.isFired() ? "Y" : "N" );
				stmt.setString( 7, tableOrderItem.isServedToCustomer() ? "Y" : "N" );
				stmt.setString( 8, isHistoricalOrderItem ? "H" : (tableOrderItem.isFired() && !tableOrderItem.isServedToCustomer() ? "K" : "C") );
				stmt.addBatch();
			}
			int[] counts = stmt.executeBatch();
		}
	}
	
	private void saveTableOrder(Connection conn, TableOrder tableOrder, int tableID) throws SQLException {
		try ( PreparedStatement stmt = conn.prepareStatement( "INSERT INTO TABLE_ORDER (TRANSACTION_ID, TABLE_ID, WAITER_ID, ORDER_DATE, SUB_TOTAL, TOTAL, IS_PAID, STATUS) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )", Statement.RETURN_GENERATED_KEYS ) ) {
			
			int waiterID = -1;
			if ( tableOrder.getWaiter() != null ) {
				waiterID = retrieveIDByName(conn, "SELECT ID FROM EMPLOYEE WHERE EMP_TYPE = 'W' AND USER_ID = ?", tableOrder.getWaiter().getUserID() );
			}
			stmt.setString( 1, tableOrder.getTransactionID() );
			stmt.setInt( 2, tableID );
			if ( waiterID < 0 ) {
				stmt.setNull( 3, Types.INTEGER );
			} else {
				stmt.setInt( 3, waiterID );
			}
			stmt.setString( 4, tableOrder.getDate() );
			stmt.setDouble( 5, tableOrder.getSubtotal() );
			stmt.setDouble( 6, tableOrder.getTotal() );
			stmt.setString( 7, tableOrder.hasPaid() ? "Y" : "N" );
			stmt.setString( 8, "C" );	
			stmt.executeUpdate();

			ResultSet rs = stmt.getGeneratedKeys();
		    if (rs.next()) {
		       int tableOrderID = rs.getInt(1);
		       saveTableOrderItems(conn, tableOrder.getOrderItems(), tableOrderID, false);
		    } else {
		    	throw new SQLException ( "Failed to save table order: " + tableOrder.getTransactionID() );
		    }
		}
	}

	/////////////////// Load Data /////////////////////
	
	
	/**
	 * Retrieve all employee records from the database
	 * @return a list of Employee objects that are retrieved from the database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public List<Employee> loadEmployees() throws SQLException {
		
		List<Employee> employeeList = new DoublyLinkedList<>();
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT NAME, PAY, USER_ID, PASSWORD, DATE_HIRED, EMAIL, SIN_NUM, POSITION, EMP_TYPE FROM EMPLOYEE" );
			while ( rs.next() ) {
				String name = rs.getString( "NAME" );
				double pay = rs.getDouble( "PAY" );
				String userId = rs.getString( "USER_ID" );
				String password = rs.getString( "PASSWORD" );
				String dataHired = rs.getString( "DATE_HIRED" );
				String email = rs.getString( "EMAIL" );
				String sinNumber = rs.getString( "SIN_NUM" );
				String position = rs.getString( "POSITION" );
				String empType = rs.getString( "EMP_TYPE" );
				Employee employee;
				if ( "C".equals ( empType ) ) {
					employee = new Chef ( name, pay, userId, password, dataHired, email, sinNumber, position );
				} else if ( "W".equals ( empType ) ) {
					employee = new Waiter ( name, pay, userId, password, dataHired, email, sinNumber, position );
				} else {
					employee = new Manager ( name, pay, userId, password, dataHired, email, sinNumber, position );
				}
				employeeList.add( employee );
			}
			return employeeList;
		}
	}

	/**
	 * Retrieve all menu item records from the database
	 * @return a list of MenuItem objects that are retrieved from the database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public List<MenuItem> loadMenu() throws SQLException, IOException {
		List<MenuItem> menu = new DoublyLinkedList<>();
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT NAME, PRICE, DESCRIPTION, CATEGORY, ICON_IMG FROM MENU_ITEM" );
			while ( rs.next() ) {
				String name = rs.getString( "NAME" );
				double price = rs.getDouble( "PRICE" );
				String description = rs.getString( "DESCRIPTION" );
				String category = rs.getString( "CATEGORY" );
				Blob image = rs.getBlob( "ICON_IMG" );
				ImageIcon imageIcon;
				byte[] imageBytes = null;
				if ( image == null ) {
					imageIcon = new ImageIcon(getClass().getResource("../images/original menu item image.JPG"));
				} else {
					imageBytes = new byte[(int)image.length() ];
					InputStream binaryStream = image.getBinaryStream(1, image.length());
					binaryStream.read(imageBytes);
					BufferedImage bufferedImage = ImageIO.read( new ByteArrayInputStream ( imageBytes ) );
					Image dimg = bufferedImage.getScaledInstance(175, 175, Image.SCALE_SMOOTH);
					imageIcon = new ImageIcon(dimg);
				}
				MenuItem menuItem = new MenuItem ( name, price, description, imageIcon, category );
				menuItem.setInternalIconImage(imageBytes);
				menu.add( menuItem );
				
			}
			return menu;
		}
	}

	/**
	 * Retrieve all customer records from the database
	 * @return a list of Customer objects that are retrieved from the database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public List<Customer> loadCustomers() throws SQLException {
		List<Customer> customerList = new DoublyLinkedList<>();
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT NAME, NUM_OF_PEOPLE FROM CUSTOMER" );
			while ( rs.next() ) {
				String name = rs.getString( "NAME" );
				int numPeople = rs.getInt( "NUM_OF_PEOPLE" );
				customerList.add( new Customer ( name, numPeople ) );
			}
			return customerList;
		}
	}

	/**
	 * Retrieve all table records from the database
	 * @return a list of Table objects that are retrieved from the database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public List<Table> loadTables(List<Customer> customers, List<Employee> employees) throws SQLException {
		List<Table> tableList = new DoublyLinkedList<>();
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT T.TABLE_NAME, T.NUM_SEATS, C.NAME AS CUSTOMER_NAME, T.CAN_BE_SERVED, E.NAME AS WAITER_NAME, T.OCCUPIED FROM RES_TABLE T LEFT OUTER JOIN CUSTOMER C ON T.CUSTOMER_ID = C.ID LEFT OUTER JOIN EMPLOYEE E ON T.WAITER_ID = E.ID" );
			while ( rs.next() ) {
				String tableName = rs.getString( "TABLE_NAME" );
				int numSeats = rs.getInt( "NUM_SEATS" );
				String customerName = rs.getString( "CUSTOMER_NAME" );
				String canBeServed = rs.getString( "CAN_BE_SERVED" );
				String waiterName = rs.getString( "WAITER_NAME" );
				String occupied = rs.getString( "OCCUPIED" );
				Table table = new Table ( tableName, numSeats, "Y".equals(canBeServed) );
				Customer customer = findCustomerByName ( customers, customerName );
				if ( customer != null ) {
					table.setCustomer(customer);
				}
				Waiter waiter = (Waiter) findEmployeeByName ( employees, waiterName );
				if ( waiter != null ) {
					table.setCurrentAssignedWaiter(waiter);
				}
				table.setOccupied( "Y".equals( occupied ) );
				tableList.add( table );
			}
			return tableList;
		}
	}

	private Employee findEmployeeByName(List<Employee> employees, String employeeName) {
		if ( employeeName == null ) {
			return null;
		}
		for ( Employee employee : employees ) {
			if ( employeeName.equals( employee.getName() ) ) {
				return employee;
			}
		}
		return null;
	}

	private Customer findCustomerByName(List<Customer> customers, String customerName) {
		if ( customerName == null ) {
			return null;
		}
		for ( Customer customer : customers ) {
			if ( customerName.equals( customer.getName() ) ) {
				return customer;
			}
		}
		return null;
	}

	/**
	 * Retrieve all reservation records from the database
	 * @return a list of Reservation objects that are retrieved from the database
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public List<Reservation> loadReservation(List<Table> tables, List<Customer> customers) throws SQLException {
		List<Reservation> reservationBook = new DoublyLinkedList<>();
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT T.TABLE_NAME, C.NAME AS CUSTOMER_NAME, RESERVED_DATE, RESERVED_TIME, CLAIMED FROM RESERVATION R LEFT OUTER JOIN CUSTOMER C ON R.CUSTOMER_ID = C.ID LEFT OUTER JOIN RES_TABLE T ON T.ID = R.TABLE_ID" );
			while ( rs.next() ) {
				String tableName = rs.getString( "TABLE_NAME" );
				String customerName = rs.getString( "CUSTOMER_NAME" );
				String reservedDate = rs.getString( "RESERVED_DATE" );
				String reservedTime = rs.getString( "RESERVED_TIME" );
				String claimed = rs.getString( "CLAIMED" );
				Customer customer = findCustomerByName ( customers, customerName );
				Table table = findTableByName ( tables, tableName );
				Reservation reservation = new Reservation ( table, "", 0, new ReservationDateTime ( reservedDate, reservedTime ) );
				reservation.setCustomer(customer);
				reservation.setClaimed( "Y".equals( claimed ) );
				reservationBook.add( reservation );
			}
			return reservationBook;
		}
	}

	private Table findTableByName(List<Table> tables, String tableName) {
		for ( Table table : tables ) {
			if ( tableName.equals( table.getTableName() ) ) {
				return table;
			}
		}
		return null;
	}

	/**
	 * Retrieve all table order records from the database. It includes unfinished orders, kitchen orders and historical orders.
	 * @return a two lists of TableOrder objects that are retrieved from the database. The two lists are contained in a Map<String, List<TableOrder>> object,
	 * with keys of "NON-HIST" and "HIST". Returned TableOrder list contains associated TableOrderItem list.
	 * @throws SQLException when encountered a database error
	 */
	@Override
	public Map<String, List<TableOrder>> loadTableOrders(List<Employee> employees, List<Table> tables, List<MenuItem> menu, Queue<TableOrderItem> kitchenOrders)
			throws SQLException {
		List<TableOrder> nonHistoricalTableOrderList = new DoublyLinkedList<>();
		List<TableOrder> historicalTableOrderList = new DoublyLinkedList<>();
		Map<String, List<TableOrder>> result = new HashMap<>();
		result.put( "NON-HIST", nonHistoricalTableOrderList );
		result.put( "HIST", historicalTableOrderList );
		
		try ( Connection conn = this.dataSource.getConnection(); 
			  Statement stmt = conn.createStatement( ) ) {
			
			ResultSet rs = stmt.executeQuery( "SELECT TOR.ID, TOR.TRANSACTION_ID, T.TABLE_NAME, E.NAME AS WAITER_NAME, TOR.ORDER_DATE, TOR.SUB_TOTAL, TOR.TOTAL, TOR.IS_PAID, TOR.STATUS FROM TABLE_ORDER TOR INNER JOIN RES_TABLE T ON TOR.TABLE_ID = T.ID INNER JOIN EMPLOYEE E ON E.ID = TOR.WAITER_ID" );
			while ( rs.next() ) {
				int tableOrderId = rs.getInt( "ID" );
				String transactionID = rs.getString( "TRANSACTION_ID" );
				String tableName = rs.getString( "TABLE_NAME" );
				String waiterName = rs.getString( "WAITER_NAME" );
				String orderDate = rs.getString( "ORDER_DATE" );
				double subTotal = rs.getDouble( "SUB_TOTAL" );
				double total = rs.getDouble( "TOTAL" );
				String isPaid = rs.getString( "IS_PAID" );
				String status = rs.getString( "STATUS" );
				Waiter waiter = (Waiter) findEmployeeByName ( employees, waiterName );
				Table table = findTableByName ( tables, tableName );
				
				TableOrder tableOrder = new TableOrder ( table );
				tableOrder.setTransactionID(transactionID);
				tableOrder.setWaiter(waiter);
				tableOrder.setDate(orderDate);
				tableOrder.setSubtotal(subTotal);
				tableOrder.setTotal(total);
				tableOrder.setPaid( "Y".equals( isPaid ) );
				
				table.setCurrentOrder(tableOrder);
				
				if ( "C".equals( status ) ) {
					nonHistoricalTableOrderList.add(tableOrder);
				} else {
					historicalTableOrderList.add(tableOrder);
				}
				
				List<TableOrderItem> tableOrderItems = retrieveTableOrderItems ( conn, tableOrder, tableOrderId, menu, employees, waiter, kitchenOrders );
				tableOrder.setOrderItems(tableOrderItems);
			}
			return result;
		}
	}

	private List<TableOrderItem> retrieveTableOrderItems(Connection conn, TableOrder tableOrder, int tableOrderId, List<MenuItem> menu,
			List<Employee> employees, Waiter waiter, Queue<TableOrderItem> kitchenOrders) throws SQLException {
		List<TableOrderItem> tableOrderItemList = new DoublyLinkedList<>();
		
		try ( PreparedStatement stmt = conn.prepareStatement( "SELECT MI.NAME AS MENU_ITEM_NAME, TOI.QUANTITY, E.NAME AS CHEF_NAME, TOI.IS_FIRED, TOI.HAS_SERVED, TOI.STATUS FROM TABLE_ORDER_ITEM TOI INNER JOIN TABLE_ORDER TOR ON TOI.TABLE_ORDER_ID = TOR.ID LEFT OUTER JOIN EMPLOYEE E ON E.ID = TOI.CHEF_ID INNER JOIN MENU_ITEM MI ON TOI.MENU_ITEM_ID = MI.ID WHERE TOI.TABLE_ORDER_ID = ?" ) ) {

			stmt.setInt(1, tableOrderId);
			
			ResultSet rs = stmt.executeQuery( );
			while ( rs.next() ) {
				String menuItemName = rs.getString( "MENU_ITEM_NAME" );
				int quantity = rs.getInt( "QUANTITY" );
				String chefName = rs.getString( "CHEF_NAME" );
				String isFired = rs.getString( "IS_FIRED" );
				String hasServed = rs.getString( "HAS_SERVED" );
				String status = rs.getString( "STATUS" );
				
				Chef chef = (Chef) findEmployeeByName(employees, chefName);
				MenuItem menuItem = findMenuItemByName ( menu, menuItemName );
				
				TableOrderItem tableOrderItem = new TableOrderItem ( menuItem, waiter, tableOrder );
				tableOrderItem.setPreparedByChef( chef );
				tableOrderItem.setQuantity(quantity);
				tableOrderItem.setFired( "Y".equals( isFired ) );
				tableOrderItem.setServedToCustomer( "Y".equals( hasServed) );
				
				tableOrderItemList.add(tableOrderItem);
				
				if ( "K".equals( status ) ) {
					kitchenOrders.enqueue(tableOrderItem);
				}
			}
			return tableOrderItemList;
		}
	}

	private MenuItem findMenuItemByName(List<MenuItem> menu, String menuItemName) {
		for ( MenuItem menuItem : menu ) {
			if ( menuItemName.equals( menuItem.getName() ) ) {
				return menuItem;
			}
		}
		return null;
	}


}
